<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerenciar Disponibilidade - Sâmia</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" href="https://raw.githubusercontent.com/WillianSoares93/cardapio_samia/refs/heads/main/logo.png" type="image/png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f3f4f6;
            visibility: hidden; /* Esconde o corpo até a autenticação ser verificada */
        }
        .tab-btn {
            transition: all 0.2s ease-in-out;
            border-bottom: 4px solid transparent;
        }
        .tab-btn.active {
            border-bottom-color: #ef4444; /* Red color for the active tab */
            color: #1f2937;
        }
        .filter-btn {
            transition: all 0.2s ease-in-out;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            padding: 24px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
        }
        /* Estilos para o Switch Tailwind */
        .peer:checked ~ .bg-gray-200 {
            background-color: #ef4444;
        }
        .peer:checked ~ .after\:translate-x-full {
            transform: translateX(100%);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4">

    <!-- Tela de Carregamento/Autenticação -->
    <div id="loading-screen" class="absolute inset-0 flex items-center justify-center bg-gray-100 z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-red-500 mx-auto"></div>
            <p class="mt-4 text-gray-700">Carregando...</p>
        </div>
    </div>

    <!-- Título Principal -->
    <div class="w-full max-w-4xl text-center mb-6">
        <h1 class="text-3xl font-bold text-gray-800">Gerenciar Cardápio</h1>
        <p class="text-gray-500">Controle a disponibilidade e visibilidade dos produtos em tempo real.</p>
    </div>

    <!-- Painel de Abas -->
    <div class="w-full max-w-4xl mb-6 bg-white rounded-lg shadow-md p-4 flex justify-between">
        <div class="flex space-x-4">
            <button id="tab-produtos-btn" class="tab-btn px-4 py-2 font-medium text-gray-600 active">Produtos</button>
            <button id="tab-ingredientes-btn" class="tab-btn px-4 py-2 font-medium text-gray-600">Ingredientes</button>
        </div>
        <div class="flex items-center space-x-2">
            <input type="text" id="search-input" placeholder="Buscar..." class="w-32 px-3 py-1 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-red-500">
            <select id="status-filter" class="text-sm px-3 py-1 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-red-500">
                <option value="Todos">Todos</option>
                <option value="Disponíveis">Disponíveis</option>
                <option value="Esgotados">Esgotados</option>
                <option value="Ocultos">Ocultos</option>
            </select>
            <select id="category-filter" class="text-sm px-3 py-1 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-red-500">
                <option value="Todos">Todas Categorias</option>
            </select>
        </div>
    </div>

    <!-- Container do Conteúdo -->
    <div id="content-container" class="w-full max-w-4xl bg-white rounded-lg shadow-md p-6">
        <div id="produtos-panel" class="panel-content">
            <!-- Conteúdo dinâmico de produtos -->
        </div>
        <div id="ingredientes-panel" class="panel-content hidden">
            <!-- Conteúdo dinâmico de ingredientes -->
        </div>
    </div>
    
    <!-- Modal de Mensagem -->
    <div id="message-modal" class="modal">
        <div class="modal-content text-center">
            <p id="modal-message" class="text-gray-700 font-medium"></p>
            <button id="close-message-modal-btn" class="mt-4 px-4 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 transition-colors">Fechar</button>
        </div>
    </div>

    <!-- Script principal -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, updateDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Configuração do Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyB9LJ-7bOvHGYyFE_H2Qd7XFcyjmSPq_ro",
            authDomain: "samia-cardapio.firebaseapp.com",
            projectId: "samia-cardapio",
            storageBucket: "samia-cardapio.firebasestorage.app",
            messagingSenderId: "223260436641",
            appId: "1:223260436641:web:adf78e77a0267f66f1e8e0"
        };

        // Inicialização do Firebase e Firestore
        let app;
        let db;
        let auth;

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
        } catch (e) {
            console.error("Erro ao inicializar o Firebase. Verifique se as variáveis de ambiente estão configuradas.", e);
            document.body.innerHTML = '<div class="text-center p-8 text-red-600">Erro: Não foi possível carregar a aplicação. Por favor, recarregue a página ou entre em contato com o suporte.</div>';
        }

        const loadingScreen = document.getElementById('loading-screen');
        const contentContainer = document.getElementById('content-container');
        const searchInput = document.getElementById('search-input');
        const statusFilter = document.getElementById('status-filter');
        const categoryFilter = document.getElementById('category-filter');
        const produtosPanel = document.getElementById('produtos-panel');
        const ingredientesPanel = document.getElementById('ingredientes-panel');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const messageModal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const closeMessageModalBtn = document.getElementById('close-message-modal-btn');
        let currentPanel = produtosPanel;

        // Exibe o modal de mensagem
        function showMessageModal(message) {
            modalMessage.textContent = message;
            messageModal.style.display = 'flex';
        }
        closeMessageModalBtn.addEventListener('click', () => {
            messageModal.style.display = 'none';
        });

        // Autenticação: redireciona para o login se não estiver autenticado
        onAuthStateChanged(auth, (user) => {
            if (user) {
                document.body.style.visibility = 'visible';
                loadingScreen.style.display = 'none';
                loadInitialData();
            } else {
                window.location.href = 'login.html';
            }
        });

        // Função para carregar os dados iniciais do cardápio e ingredientes
        async function loadInitialData() {
            try {
                const response = await fetch('/api/menu');
                if (!response.ok) {
                    throw new Error(`Erro na rede: ${response.statusText}`);
                }
                const data = await response.json();
                
                // Popula o filtro de categorias
                const categories = new Set(data.cardapio.map(item => item.category).filter(c => c));
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categoryFilter.appendChild(option);
                });

                renderPanel(data.cardapio, 'produtos', produtosPanel);
                renderPanel(data.ingredientesHamburguer, 'ingredientes', ingredientesPanel);

                // Configura o listener do Firestore para atualizações em tempo real
                setupFirestoreListeners(data);

            } catch (error) {
                console.error("Erro ao carregar os dados:", error);
                showMessageModal("Não foi possível carregar os dados. Verifique sua conexão e tente novamente.");
            }
        }

        // Configura o listener em tempo real do Firestore
        function setupFirestoreListeners(initialData) {
            if (!db) return;

            const itemStatusRef = doc(db, "config", "item_status");
            const ingredientStatusRef = doc(db, "config", "ingredient_status");
            const itemVisibilityRef = doc(db, "config", "item_visibility");
            const ingredientVisibilityRef = doc(db, "config", "ingredient_visibility");

            onSnapshot(itemStatusRef, (docSnap) => {
                const config = docSnap.exists() ? docSnap.data() : {};
                const updatedItems = initialData.cardapio.map(item => ({
                    ...item,
                    available: config[item.id] && config[item.id].available !== undefined ? config[item.id].available : true,
                    allowHalfAndHalf: config[item.id] && config[item.id].allowHalfAndHalf !== undefined ? config[item.id].allowHalfAndHalf : true,
                    visible: config[item.id] && config[item.id].visible !== undefined ? config[item.id].visible : true
                }));
                renderPanel(updatedItems, 'produtos', produtosPanel);
                filterAndRender();
            });

            onSnapshot(ingredientStatusRef, (docSnap) => {
                const config = docSnap.exists() ? docSnap.data() : {};
                const updatedIngredients = initialData.ingredientesHamburguer.map(item => ({
                    ...item,
                    available: config[item.id] && config[item.id].available !== undefined ? config[item.id].available : true,
                    visible: config[item.id] && config[item.id].visible !== undefined ? config[item.id].visible : true
                }));
                renderPanel(updatedIngredients, 'ingredientes', ingredientesPanel);
                filterAndRender();
            });
        }
        
        // Renderiza o painel
        function renderPanel(items, type, panel) {
            panel.innerHTML = '';
            const groupedItems = groupByCategory(items);
            for (const category in groupedItems) {
                const categoryGroup = document.createElement('div');
                categoryGroup.className = 'category-group mb-6';
                categoryGroup.setAttribute('data-category-group', category);
                categoryGroup.innerHTML = `<h2 class="text-xl font-bold text-gray-700 mb-4">${category}</h2>`;
                groupedItems[category].forEach(item => {
                    categoryGroup.appendChild(createAvailabilityRow(item, type));
                });
                panel.appendChild(categoryGroup);
            }
        }

        // Cria a linha de um item
        function createAvailabilityRow(item, type) {
            const isPizza = item.category.toLowerCase().includes('pizza');
            let halfHalfSwitchHtml = '';

            // Lógica para adicionar o switch de 'meia a meia' apenas para pizzas
            if (isPizza) {
                halfHalfSwitchHtml = `
                    <div class="flex items-center space-x-2 mr-4">
                        <span class="text-xs text-gray-500">Meia a Meia</span>
                        <label for="half-half-${item.id}" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="half-half-${item.id}" class="peer sr-only" ${item.allowHalfAndHalf ? 'checked' : ''}>
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-red-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-red-600"></div>
                        </label>
                    </div>
                `;
            }

            const row = document.createElement('div');
            row.className = 'availability-row flex items-center justify-between p-4 border-b border-gray-200';
            row.setAttribute('data-id', item.id);
            row.setAttribute('data-category', item.category);
            row.setAttribute('data-name', item.name);
            row.setAttribute('data-available', item.available);
            row.setAttribute('data-visible', item.visible);
            row.setAttribute('data-allow-half', item.allowHalfAndHalf);
            
            row.innerHTML = `
                <div class="flex items-center space-x-4 flex-1">
                    <span class="font-semibold text-gray-800">${item.name}</span>
                </div>
                <div class="flex items-center">
                    ${halfHalfSwitchHtml}
                    <!-- Switch de Disponibilidade -->
                    <div class="flex items-center space-x-2 mr-4">
                        <span class="text-xs text-gray-500">Disponível</span>
                        <label for="available-${item.id}" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="available-${item.id}" class="peer sr-only" ${item.available ? 'checked' : ''}>
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-red-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-green-600"></div>
                        </label>
                    </div>
                    <!-- Switch de Visibilidade -->
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-gray-500">Visível</span>
                        <label for="visible-${item.id}" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="visible-${item.id}" class="peer sr-only" ${item.visible ? 'checked' : ''}>
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-red-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-red-600"></div>
                        </label>
                    </div>
                </div>
            `;

            // NOVO: Adiciona o listener para o novo switch de "meia a meia"
            if (isPizza) {
                const halfHalfSwitch = row.querySelector(`#half-half-${item.id}`);
                halfHalfSwitch.addEventListener('change', async (e) => {
                    const newStatus = e.target.checked;
                    const itemConfigRef = doc(db, "config", "item_status");
                    try {
                        await updateDoc(itemConfigRef, {
                            [`${item.id}.allowHalfAndHalf`]: newStatus
                        });
                        console.log(`Status de 'meia a meia' para ${item.id} atualizado para ${newStatus}.`);
                    } catch (error) {
                        console.error("Erro ao atualizar o status de 'meia a meia':", error);
                        showMessageModal("Ocorreu um erro ao salvar a alteração.");
                    }
                });
            }

            // Listener para o switch de disponibilidade (já existia)
            const availableSwitch = row.querySelector(`#available-${item.id}`);
            if (availableSwitch) {
                availableSwitch.addEventListener('change', async (e) => {
                    const newStatus = e.target.checked;
                    const itemConfigRef = doc(db, "config", `${type === 'produtos' ? 'item_status' : 'ingredient_status'}`);
                    try {
                        await updateDoc(itemConfigRef, {
                            [`${item.id}.available`]: newStatus
                        });
                        console.log(`Disponibilidade para ${item.id} atualizada para ${newStatus}.`);
                    } catch (error) {
                        console.error("Erro ao atualizar a disponibilidade:", error);
                        showMessageModal("Ocorreu um erro ao salvar a alteração.");
                    }
                });
            }
            
            // Listener para o switch de visibilidade (já existia)
            const visibleSwitch = row.querySelector(`#visible-${item.id}`);
            if (visibleSwitch) {
                visibleSwitch.addEventListener('change', async (e) => {
                    const newStatus = e.target.checked;
                    const itemConfigRef = doc(db, "config", `${type === 'produtos' ? 'item_status' : 'ingredient_status'}`);
                    try {
                        await updateDoc(itemConfigRef, {
                            [`${item.id}.visible`]: newStatus
                        });
                        console.log(`Visibilidade para ${item.id} atualizada para ${newStatus}.`);
                    } catch (error) {
                        console.error("Erro ao atualizar a visibilidade:", error);
                        showMessageModal("Ocorreu um erro ao salvar a alteração.");
                    }
                });
            }

            return row;
        }

        // Funções de filtro (já existentes)
        function filterAndRender() {
            const searchText = searchInput.value.toLowerCase();
            const selectedStatus = statusFilter.value;
            const selectedCategory = categoryFilter.value;
            
            const rows = currentPanel.querySelectorAll('.availability-row');
            rows.forEach(row => {
                const itemName = row.getAttribute('data-name').toLowerCase();
                const itemCategory = row.getAttribute('data-category');
                const isAvailable = row.getAttribute('data-available') === 'true';
                const isVisible = row.getAttribute('data-visible') === 'true';

                const nameMatch = itemName.includes(searchText);
                const categoryMatch = selectedCategory === 'Todos' || itemCategory === selectedCategory;
                
                let statusMatch;
                switch(selectedStatus) {
                    case 'Disponíveis':
                        statusMatch = isAvailable && isVisible;
                        break;
                    case 'Esgotados':
                        statusMatch = !isAvailable && isVisible;
                        break;
                    case 'Ocultos':
                        statusMatch = !isVisible;
                        break;
                    default: // 'Todos'
                        statusMatch = true;
                }

                if (nameMatch && categoryMatch && statusMatch) {
                    row.style.display = 'flex';
                } else {
                    row.style.display = 'none';
                }
            });

            // Oculta grupos de categorias vazios
            currentPanel.querySelectorAll('[data-category-group]').forEach(titleDiv => {
                const hasVisibleItems = Array.from(titleDiv.querySelectorAll('.availability-row')).some(row => row.style.display !== 'none');
                titleDiv.style.display = hasVisibleItems ? 'block' : 'none';
            });
        }

        // Funções para agrupar e gerenciar abas (já existentes)
        function groupByCategory(items) {
            if (!Array.isArray(items)) return {};
            return items.reduce((acc, item) => {
                const category = item.category || 'Outros';
                if (!acc[category]) {
                    acc[category] = [];
                }
                acc[category].push(item);
                return acc;
            }, {});
        }
        
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                if (btn.id === 'tab-produtos-btn') {
                    produtosPanel.classList.remove('hidden');
                    ingredientesPanel.classList.add('hidden');
                    currentPanel = produtosPanel;
                } else {
                    produtosPanel.classList.add('hidden');
                    ingredientesPanel.classList.remove('hidden');
                    currentPanel = ingredientesPanel;
                }
                filterAndRender();
            });
        });
        
        searchInput.addEventListener('input', filterAndRender);
        statusFilter.addEventListener('change', filterAndRender);
        categoryFilter.addEventListener('change', filterAndRender);

    </script>
</body>
</html>
